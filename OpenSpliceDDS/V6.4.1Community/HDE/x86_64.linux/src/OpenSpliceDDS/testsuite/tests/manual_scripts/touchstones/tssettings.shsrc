#!/bin/bash

# This file must only be sourced.
if [ -z "$BASH_SOURCE" -o "$0" = "$BASH_SOURCE" ]; then
    echo "ERROR: Only source '$0' file"
    exit 1
fi

# Source current settings.
. "$(dirname "$BASH_SOURCE")/../osplsettings.shsrc" "$@"
. "$(dirname "$BASH_SOURCE")/../ospltestutils.shsrc" "$@"
. "$(dirname "$BASH_SOURCE")/../osplconfig.shsrc" "$@"
. "$(dirname "$BASH_SOURCE")/../stafutils.shsrc" "$@"

# Setup STAF environment.
source_staf_env || exit 1

# We plainly hardcode some of the values. There is no sense to make these
# parameters configurable as they change very rarely.
g_test_duration=180
g_master_ts_group_id=1001
g_slave_ts_group_id=2001
g_master_recorder_script="$TS_ROOT/examples/simple/latency/simple_latency_recording.dat"
g_master_ts_start_app_id=1
g_slave_ts_start_app_id=1
g_tsscript="$SRC_ROOT/ospli/testsuite/tests/touchstones/run_test.xml"
# Exit status of run_tests which we cannot directly return in bash
# since we pipe script output to tee.
g_touchstones_failed=0

function check_ts_dir ()
{
    if [ -z "$TS_ROOT" -o ! -d "$(to_unix_path "$TS_ROOT")" ]; then
        error_help "ERROR: Touchstone not found at '$TS_ROOT'"
        return 1
    fi
}

function check_ts_prereqs ()
{
    which patch &>/dev/null || error_help "ERROR: 'patch' executable is not found" || return 1
    if [ "$(uname -o)" = 'Cygwin' ]; then
        which cl &>/dev/null || error_help "ERROR: 'cl' executable is not found" || return 1
        which link &>/dev/null || error_help "ERROR: 'link' executable is not found" || return 1
        test "$(which link)" != '/bin/link' || error_help "ERROR: 'link' executable is a GNU link" || return 1
    else
        which make &>/dev/null || error_help "ERROR: 'make' executable is not found" || return 1
    fi
}

function _run_tests ()
{
    if [ $# -ne 7 ]; then
        error_trace "ERROR: Wrong number of arguments to ${FUNCNAME[0]}"
        return 1
    fi

    # Check if there are no stupid mistakes related to remote hosts.
    check_testing_prereqs || return 1

    local testfunction="$1" && test -n "$testfunction" || error_trace "ERROR: Parameter \$1 is empty" || return 1
    local masterhost="$2" && test -n "$masterhost" || error_trace "ERROR: Parameter \$2 is empty" || return 1
    local slavehosts="$3" && test -n "$slavehosts" || error_trace "ERROR: Parameter \$3 is empty" || return 1
    local runtypes="$4" && test -n "$runtypes" || error_trace "ERROR: Parameter \$4 is empty" || return 1
    local transports="$5" && test -n "$transports" || error_trace "ERROR: Parameter \$5 is empty" || return 1
    local multiplicities="$6" && test -n "$multiplicities" || error_trace "ERROR: Parameter \$6 is empty" || return 1
    local implementations="$7" && test -n "$implementations" || error_trace "ERROR: Parameter \$7 is empty" || return 1

    local masterospl masterlog mastertsbin
    masterospl="$(remote_var_value "$masterhost" OSPL_DISTPATH)" || return 1
    masterlog="$(remote_var_value "$masterhost" LOG_DIR)" || return 1
    mastertsbin="$(remote_var_value "$masterhost" TS_BIN)" || return 1

    if [ -n "$g_cleanlogs" ]; then
        echo -e "\nDeleting old logs on '$masterhost'..."
        STAF "$masterhost" FS DELETE ENTRY "$masterlog" CONFIRM RECURSE || return 1
    fi

    # Note slavehosts is not quoted so that each word in slavehosts is
    # processed separately. Ditto for other internal loops.
    local slavehost transport multi impl slaveospl slavelog slavetsbin
    for slavehost in $slavehosts
    do
        slaveospl="$(remote_var_value "$slavehost" OSPL_DISTPATH)" || return 1
        slavelog="$(remote_var_value "$slavehost" LOG_DIR)" || return 1
        slavetsbin="$(remote_var_value "$slavehost" TS_BIN)" || return 1

        if [ -n "$g_cleanlogs" -a "$masterhost" != "$slavehost" ]; then
            echo -e "\nDeleting old logs on '$slavehost'..."
            STAF "$slavehost" FS DELETE ENTRY "$slavelog" CONFIRM RECURSE || return 1
        fi

        for runtype in $runtypes
        do
            for transport in $transports
            do
                # Make sure that the log dirs exist on both hosts.
                local masterfulllog="$masterlog/touchstones/$masterhost/$slavehost/$runtype/$transport"
                echo -e "\nCreating a new log dir '$masterfulllog' on '$masterhost'..."
                STAF "$masterhost" FS CREATE DIRECTORY "$masterfulllog" FULLPATH || return 1
                local slavefulllog="$slavelog/touchstones/$runtype/$transport"
                echo -e "\nCreating a new log dir '$slavefulllog' on '$slavehost'..."
                STAF "$slavehost" FS CREATE DIRECTORY "$slavefulllog" FULLPATH || return 1

                # Create OSPL configs specific to this run.
                change_remote_configs "$masterhost" "$runtype" "$transport" || return 1
                change_remote_configs "$slavehost" "$runtype" "$transport" || return 1

                for multi in $multiplicities
                do
                    for impl in $implementations
                    do
                        eval "\"$testfunction\" \"$masterhost\" \"$masterfulllog\" \"$masterospl\" \"$mastertsbin\" \"$slavehost\" \"$slavefulllog\" \"$slaveospl\" \"$slavetsbin\" \"$runtype\" \"$transport\" \"$multi\" \"$impl\""
                        if [ $? -ne 0 -a -z "$g_force_tests" ]; then
                            return 1
                        fi
                    done
                done

                if [ -n "$g_cleanlogs" -a "$masterhost" != "$slavehost" ]; then
                    echo -e "\nDeleting logs for '$transport' on '$slavehost'..."
                    STAF "$slavehost" FS DELETE ENTRY "$slavefulllog" CONFIRM RECURSE || return 1
                fi
            done
        done
    done

    return 0
}

function run_tests ()
{
    test $g_touchstones_failed -eq 0 && _run_tests "$@" || g_touchstones_failed=1
}

function savelogs ()
{
    if [ $# -ne 1 ]; then
        error_trace "ERROR: Wrong number of arguments to ${FUNCNAME[0]}"
        return 1
    fi

    local resultdir="$1" && test -n "$resultdir" -a -d "$resultdir" || error_trace "ERROR: Parameter \$1 is empty" || return 1

    # Save the config files for the report.
    find "$(osplconfig_current_path)/" -maxdepth 1 -regex '.*\.xml$' -exec mv -f '{}' "$resultdir" \; || return 1

    # Save the screen.log.
    find "$PWD/" -maxdepth 1 -name 'screen.log' -exec mv -f '{}' "$resultdir" \; || return 1

    # STAX scripts for Touchstones are written so that in some cases they leave
    # ospl-error.log/ospl-info.log in the current directory.
    find "$PWD/" -maxdepth 1 -name 'ospl-error.log' -o -name 'ospl-info.log' -exec mv -f '{}' "$resultdir" \; || return 1

    echo -e "\nArchiving the logs..."
    tar -czf "$PWD/touchstones_$(basename "$resultdir")_$(date +%F_%s).tgz" -C "$(dirname "$resultdir")" "$(basename "$resultdir")"
}

function _check_tssettings_args ()
{
    while [ $# -ne 0 ]
    do
        case "$1" in
            -h|--help)
                # Nothing to print as help here.
                return 1
                ;;
            *)
                shift
                ;;
        esac
    done
}
if [ -z "$g_tssetting_loaded" ]; then
    g_tssetting_loaded='yes'
    # This is the last line in this file. It can set $? which is important for
    # the outside code. Don't do anything after this!!!
    _check_tssettings_args "$@"
fi
